CHARACTER CONTROLLER ARCHITECTURE — CONVERSATION LOG
=====================================================
Date: 2026-02-17
Project: BarafPani (Unity Multiplayer — Hide & Seek)

=======================================================
USER:
=======================================================

i want to create a character controller. however, im thinking of its structure like this: character class should handle main initialization related code. rest of the features should only be handled by their respective names e.g. walk, sprint, crouch, etc. now, the character shouldn't have its concerns whether or not these scripts are attached to it. however, the features, require the character class itself. advise, don't write any code. even if i remove a component from the character's game object, the character class shouldn't break

=======================================================
RESPONSE:
=======================================================

Good instinct. Here's how to think about it.

## The Core Pattern: Hub and Spokes

**Character** is the hub. It owns shared dependencies — Rigidbody, Animator, Collider, ground-check data, whatever every feature needs access to. It exposes these as public properties. That's it. It does not reference, call, or even know about any feature.

**Features** (Walk, Sprint, Crouch) are spokes. Each one requires Character via `[RequireComponent]`. They grab the Character reference in Awake and pull what they need from it. If you delete a feature component, Character never notices.

## The Hard Part: Feature-to-Feature Communication

Sprint needs to know if you're crouching. Crouch might need to know if you're airborne. You have three realistic options:

**Option A — Shared State Blackboard on Character.** Character holds a simple data container (a struct or a few flat fields) representing current movement state: grounded, velocity, stance, etc. Features write to it, features read from it. Character doesn't interpret any of it — it's just a shared clipboard. This is the simplest and what I'd recommend for your case.

**Option B — Features query each other via TryGetComponent.** Sprint does `TryGetComponent<Crouch>(out var crouch)` and checks if crouching. This works, but now features have soft awareness of each other. It's nullable, so nothing breaks if Crouch is missing — Sprint just skips that check. Acceptable for small feature sets, gets messy at scale.

**Option C — Event bus.** Character or a separate broker holds events. Features subscribe and publish. More decoupled, more indirection, more boilerplate. Overkill unless you're building a system with 15+ features or modding support.

## My Recommendation

Go with **Option A** as the backbone, **Option B** as a fallback for edge cases.

Character holds a lightweight state struct. Every feature writes its contribution to that state during its update. Every feature reads whatever it needs from that same state. Character exposes shared components and shared state — nothing else.

## Initialization Order

Use `Awake` in Character to cache Rigidbody, Animator, etc. Use `OnEnable` or `Start` in features to grab their Character reference. This guarantees Character is ready before any feature touches it. If you want extra safety, set Character's Script Execution Order earlier than default.

## One Rule to Enforce

Character must have **zero** `GetComponent` calls for any feature type. The moment Character references Walk or Sprint, you've inverted the dependency and the whole structure collapses. If you find yourself wanting Character to call a feature, that's a signal the logic belongs in the feature, not in Character.

That's the architecture. Tell me when you want code.

=======================================================
USER:
=======================================================

I expect to add abilities inside character, and have two character types as well: such as the hider and seeker in a hide n seek game for example. we have unity atoms available in this project that can handle events gracefully

=======================================================
RESPONSE:
=======================================================

This changes the picture meaningfully. Let me reframe.

## Character Stays Dumb, Gains an Ability Slot

Character still owns shared dependencies (Rigidbody, Animator, etc.). Now it also holds an **ability container** — a simple list of abilities that can be added/removed at runtime. Character doesn't know what abilities are in the list. It just provides the bucket and a registration API (Add, Remove, Get by type). That's the only new responsibility.

## Hider and Seeker: Composition, Not Inheritance

Do not subclass Character into HiderCharacter and SeekerCharacter. You'll regret it within a week.

Instead, create a **RoleDefinition** ScriptableObject. It holds role-specific config: which abilities this role gets, any stat overrides, and role-scoped Atom Events. Make two instances — one for Hider, one for Seeker. Character gets a serialized RoleDefinition field. At init, Character reads its assigned role and populates its ability container accordingly.

If the roles diverge in behavior (not just data), add a thin **Role component** — `HiderRole`, `SeekerRole` — that sits alongside Character the same way features do. It references Character, not the other way around. Character only knows it has a RoleDefinition SO. It never knows which role it is. This keeps the door open for adding a third role later without touching Character.

## Abilities vs Features: Draw the Line Now

**Features** (Walk, Sprint, Crouch) are locomotion-layer components. Always present on every character regardless of role. They live as sibling components, depend on Character, operate through shared state.

**Abilities** (Hide, Tag, Scan, Disguise) are role-specific actions. They get registered into Character's ability container based on RoleDefinition. They have activation conditions, cooldowns, and potentially exclusive states (can't hide while being tagged). These should be ScriptableObject-defined, MonoBehaviour-executed — meaning the ability's data/config lives in a SO, but a runtime component handles execution and state.

## Where Unity Atoms Fits

Atoms replaces the blackboard struct I mentioned before. Here's the mapping:

**Shared movement state** — BoolVariable atoms for `IsGrounded`, `IsCrouching`, `IsSprinting`. Features write to these. Other features and abilities subscribe to their Changed events. No polling, no direct references between components.

**Ability events** — VoidEvent or custom AtomEvent SOs for things like `OnAbilityActivated`, `OnTagged`, `OnHidden`. The role components and UI subscribe to these. Clean decoupling.

**Stat values** — FloatVariable atoms for `MoveSpeed`, `StaminaCurrent`, etc. Abilities and features both read from these. A Sprint ability modifies `MoveSpeed`; the Walk feature just reads it and applies it. Neither knows the other exists.

## The Critical Problem: Atom Instancing

Unity Atoms variables are ScriptableObjects — shared singletons by default. If you have two characters in the scene, they'll stomp on each other's `IsGrounded` atom.

You have two paths:

**Path A — Instanced Atoms.** Unity Atoms supports `AtomInstancer` components that create per-GameObject copies of atom variables at runtime. Each character gets its own instance. Features and abilities reference the instancer, not the SO directly. This is the intended solution but adds a layer of indirection.

**Path B — Atoms for global events only, plain C# for per-character state.** Use Atoms for game-level events (round start, player tagged, game over) and keep per-character state as a simple C# class owned by Character. Features read/write to that class. This is simpler but means you lose Atom's change-listening on per-character state.

**My call:** Path A if you're committed to Atoms throughout. Path B if you want less friction now and don't mind a hybrid approach. For a hide-and-seek game with two character types, Path B is probably the pragmatic choice — you won't have dozens of characters and the per-character state is straightforward enough that Atoms' reactive features aren't strictly necessary at that layer.

## Dependency Flow Summary

```
RoleDefinition (SO) ──defines──> Abilities + Config
        │
        ▼
   Character (hub) ──owns──> Ability Container + Shared State
        ▲                         ▲
        │                         │
   ┌────┴────┐              ┌─────┴─────┐
Features    Role          Abilities read/write
(Walk,etc)  Component     shared state
read/write  (optional)
shared state

Unity Atoms: global game events + optionally per-character state via instancing
```

Nothing points downward from Character to any feature, ability, or role component. Everything reaches up to Character. Character breaks if you remove Rigidbody — that's it.

Your call on the instancing path. Tell me which way and I'll structure the code.

=======================================================
USER:
=======================================================

so should i go with the previously mentioned 'path c'

=======================================================
RESPONSE:
=======================================================

There was no Path C. I gave two paths for Atom instancing (A and B) and three options for feature communication earlier (A, B, C).

Which are you referring to — Option C from the first message (event bus via Unity Atoms for feature-to-feature communication), or something you're synthesizing from both responses? Clarify and I'll give you a straight answer.

=======================================================
USER:
=======================================================

option c from the first message. i dont mind using a hybrid approach; i only intend to keep unity atom's event systems since i don't think atom variables would be much required, custom scriptable objects for data would be fine

=======================================================
RESPONSE:
=======================================================

That's the right call for this project scope.

Unity Atoms events for decoupled communication, your own ScriptableObjects for data/config. You skip the instancing headache entirely since Atom Events are fire-and-forget — they don't hold per-character state, they just broadcast. No collision between multiple characters.

The shared state on Character becomes a plain C# class or a few flat fields. Features and abilities write to it directly, and when something needs to notify other systems, it raises an Atom Event. Simple read = check the state. Reactive response = subscribe to the event.

One thing to lock down: scope your Atom Events clearly. You'll want two tiers.

**Character-scoped events** — things like `OnSprint`, `OnCrouch`, `OnAbilityActivated`. These are per-character. Since Atom Events are shared SOs, you'll need to pass the character reference as a payload (use a custom AtomEvent with your Character type as the argument) so listeners can filter by who raised it. Otherwise every character reacts to every other character's crouch event.

**Game-scoped events** — things like `OnRoundStart`, `OnPlayerTagged`, `OnGameOver`. These are truly global, no filtering needed. Standard Atom VoidEvents or typed events work cleanly here.

As long as you maintain that distinction, the hybrid holds up. Ready for code whenever you are.

=======================================================
USER:
=======================================================

game scoped events are fine, not character scoped events. i believe character scoped events will stay within the character which wouldn't need a global singleton for everything. the scripts stay within a prefab too

=======================================================
RESPONSE:
=======================================================

You're right. Character-scoped communication stays local — plain C# events or delegates on the Character class itself. The features are sibling components on the same prefab, they already have a direct reference to Character, so they just subscribe to Character's C# events directly. No reason to route local communication through a ScriptableObject singleton.

Atoms events handle game-level broadcasts only. Everything inside the character prefab talks through plain C#.

Clean separation. Ready for code when you are.

=======================================================
USER:
=======================================================

give me an example of Option C — Event bus. Character or a separate broker holds events. Features subscribe and publish. More decoupled, more indirection, more boilerplate. Overkill unless you're building a system with 15+ features or modding support. , this with the above approaches in consideration

=======================================================
RESPONSE:
=======================================================

[Entered plan mode to explore codebase and design implementation]

## Exploration Results

Existing project structure:
- Assets/_Features/Player/Scripts/Character.cs — stub MonoBehaviour with CharacterController ref
- Assets/_Features/Player/_Features/Input/CharacterInput.cs — [RequireComponent(typeof(Character))]
- Assets/_Features/Player/_Features/Walk/Scripts/CharacterWalk.cs — same pattern
- Assets/_Features/Player/_Features/Sprint/Scripts/CharacterSprint.cs — same pattern
- Assets/_Features/Player/_Features/Crouch/Scripts/CharacterCrouch.cs — same pattern
- Assets/_Features/Player/_Features/Grab/Scripts/CharacterGrab.cs — same pattern
- All stubs, namespace mirrors folder path
- Unity Atoms full suite installed (canary branch)
- Netcode for GameObjects 2.9.2
- PROJECT_STRUCTURE.md with detailed architecture doc

## Plan Created

### Files to Create/Modify

| File | Action | Location |
|------|--------|----------|
| CharacterEventBus.cs | Create | Assets/_Features/Player/Scripts/ |
| CharacterEvents.cs | Create | Assets/_Features/Player/Scripts/ |
| CharacterFeature.cs | Create | Assets/_Features/Player/Scripts/ |
| Character.cs | Modify | Assets/_Features/Player/Scripts/ |
| CharacterSprint.cs | Modify | Assets/_Features/Player/_Features/Sprint/Scripts/ |
| CharacterCrouch.cs | Modify | Assets/_Features/Player/_Features/Crouch/Scripts/ |

### CharacterEventBus.cs
Plain C# class. Generic Subscribe<T> / Unsubscribe<T> / Publish<T> / Clear.
- Backed by Dictionary<Type, List<Delegate>>
- where T : struct constraint
- Publish iterates a snapshot (ToArray()) for safe iteration
- No try/catch, no thread safety
- Clear() called from Character.OnDestroy()

### CharacterEvents.cs
All event structs in one file:
- SprintStateChangedEvent { bool IsSprinting }
- CrouchStateChangedEvent { bool IsCrouching }
- MoveInputEvent { Vector2 Input }
- GrabStateChangedEvent { bool IsGrabbing }
All readonly struct with readonly fields.

### CharacterFeature.cs
Abstract base class:
- [RequireComponent(typeof(Character))]
- protected Character (cached in Awake)
- protected CharacterEventBus EventBus (shortcut)

### Character.cs Modifications
- Add EventBus property with lazy init
- Expose Controller as public read-only
- Awake: create EventBus
- OnDestroy: EventBus.Clear()
- Remove empty Start/Update

### Sprint + Crouch Example
CharacterSprint: subscribes to CrouchStateChangedEvent, publishes SprintStateChangedEvent
CharacterCrouch: subscribes to SprintStateChangedEvent, blocks crouching during sprint

### Event Flow
```
CharacterSprint
  |-- publishes SprintStateChangedEvent --> CharacterCrouch (blocks/unblocks)
  |                                     --> CharacterWalk (speed multiplier, future)

CharacterCrouch
  |-- publishes CrouchStateChangedEvent --> CharacterSprint (cancels sprint)
  |                                     --> CharacterWalk (speed multiplier, future)
```

[Plan approved by user, began implementation]

=======================================================
USER:
=======================================================

[Rejected the CharacterEventBus.cs file creation]

wasn't that event bus too complicated? i was thinking of having solo events one by one instead of a whole event bus

=======================================================
RESPONSE:
=======================================================

You're right, the generic dictionary bus is overkill for your feature count.

Simplest version: plain `event Action` fields directly on Character. One line per event. Features raise them, features subscribe to them. Character is still just the mailbox — it doesn't listen to or handle any of them.

```csharp
// On Character
public event Action<bool> OnSprintStateChanged;
public event Action<bool> OnCrouchStateChanged;
```

The tradeoff: adding a new feature event means adding one line to Character.cs. Character gains conceptual awareness that "sprint events exist" but has zero knowledge of who publishes or subscribes. No generics, no dictionaries, no bus class.

The alternative: each feature declares its own events, and other features use `TryGetComponent` to find siblings and subscribe. But your project structure doc states features shouldn't reference each other's assemblies, which kills that approach once you add asmdefs.

Do you want the events living directly on Character, or should I keep Character completely clean and put them on a separate thin `CharacterEvents` MonoBehaviour that sits alongside Character?

=======================================================
END OF CONVERSATION LOG
=======================================================

DECISIONS MADE:
- Hub-and-spoke architecture: Character is hub, features are spokes
- Composition over inheritance for Hider/Seeker roles (RoleDefinition SO)
- Unity Atoms for game-scoped events only (OnRoundStart, OnPlayerTagged, etc.)
- Plain C# for per-character communication (local to prefab)
- Custom ScriptableObjects for data/config (not Atom Variables)
- No Atom instancing needed
- Features separated: locomotion (always present) vs abilities (role-dependent)
- CharacterFeature abstract base class to reduce boilerplate

PENDING DECISION:
- Events on Character directly vs separate CharacterEvents MonoBehaviour